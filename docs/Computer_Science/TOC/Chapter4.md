---
statistics: True
comments: true
---

# Chapter 4 | Turing Machine

**为什么需要图灵机？**

在我们学习图灵机之前，我们已经接触了两种计算模型：

1.  **有限自动机 (Finite Automata, FA)**：

**模型**：一个只有有限多个状态（有限内存）的控制器，一个只读、单向（从左到右）的输入带。

* **能力**：只能识别“正则语言”，例如 $a^*$。
* **局限**：内存是有限的。它无法“计数”。例如，它无法识别 $L = \{a^n b^n \mid n \ge 0\}$，因为它不记得自己读了多少个 $a$。

2.  **下推自动机 (Pushdown Automata, PDA)**：

**模型**：一个 FA 加上一个**栈 (Stack)** 。栈是无限的，但访问受限（后进先出 LIFO）。

* **能力**：能识别“上下文无关语言”(CFL)，例如 $L = \{a^n b^n\}$。它可以通过“压栈”来“计数” $a$，再通过“弹栈”来匹配 $b$。
* **局限**：

    * **访问受限**：栈顶是唯一的读写位置。
    * **只读输入**：输入带仍然是只读、单向的。
    * 它无法识别 $L = \{ww \mid w \in \{a,b\}^*\}$（一个字符串的完美复制）。为什么？因为当它在读取第二个 $w$ 时，它需要拿 $w$ 的第一个字符去和*栈底*（即 $w$ 的第一个字符）比较，但它做不到，它只能访问栈顶。
    * 它也无法识别 $L = \{a^n b^n c^n\}$。因为栈在匹配完 $b^n$ 后就空了，它“忘记”了 $n$ 到底是多少，无法再用来匹配 $c^n$。

**图灵机的出现**

图灵机的设计思想就是为了克服上述所有局限。它问了一个问题：“如果我们把 PDA 的栈和 FA 的输入带合并，并让这个‘带子’变得既可读又可写，并且磁头可以双向移动呢？” 。

这就是图灵机 (Turing Machine, TM) 的核心理念。它引入了几个革命性的新特性：

* 磁头可以**同时读和写** 。
* 磁头可以**双向移动**（左或右）。
* 带子是**无限长的**（至少在概念上是这样，总有空白格可用） 。

---

## 图灵机的形式化定义

就像 FA 和 PDA 一样，一个图灵机 (TM) 被定义为一个**五元组 (quintuple)**：

$$M = (K, \Sigma, \delta, s, H)$$

我们来逐一拆解这五个组成部分：

* **$K$ (状态集)**：一个**有限**的状态集合。

* **$\Sigma$ (带字母表)**：这是一个**有限**的字母表。
    * 它必须包含一个特殊的**空白符号 $\sqcup$**（有时也写作 $\diamond$ 或 $B$）。
    * 它必须包含一个特殊的**左端点符号 $\triangleright$**。这标志着磁带的“起点”，磁头永远不能移动到它的左边。
    * 它**不包含**移动符号 $\leftarrow$ 和 $\rightarrow$（这些是“动作”，不是“符号”）。

* **$s$ (初始状态)**：$s \in K$，是机器开始时的状态。

* **$H$ (停机状态集)**：$H \subseteq K$，是一个或多个状态的集合。

* **$\delta$ (转移函数)**：这是图灵机的“程序”或“大脑”，也是最复杂的部分。

    * **数学定义**：$\delta: (K-H) \times \Sigma \to K \times (\Sigma \cup \{\leftarrow, \rightarrow\})$ 。
    * **输入 $(K-H) \times \Sigma$**：函数的输入是 (当前状态, 当前磁头下的符号)。注意，状态必须是**非停机状态** ($K-H$)。
    * **输出 $K \times (\Sigma \cup \{\leftarrow, \rightarrow\})$**：函数的输出是 (新状态, 要执行的动作)。这个“动作”*要么*是“写入一个新符号”（来自 $\Sigma$），*要么*是“移动磁头”（$\leftarrow$ 或 $\rightarrow$）。
    * **重要约束 (安全规则)**：

        1.  $\forall q \in K-H, \text{如果 } \delta(q, \triangleright) = (p, b), \text{ 那么 } b \text{ 必须是 } \rightarrow$。这条规则是说，当磁头在最左端的 $\triangleright$ 符号上时，它**唯一**允许的动作就是向右移动。它绝不能向左移（掉下磁带），也绝不能改写 $\triangleright$ 符号。
        2.  $\forall q \in K-H \text{ 和 } a \in \Sigma, \text{如果 } \delta(q, a) = (p, b), \text{ 那么 } b \ne \triangleright$。这说明图灵机永远不能“写入” $\triangleright$ 符号。$\triangleright$ 只能在初始时出现在磁带的最左端。

---

### 图灵机的图示表示

![img](./assets/4-1.png)

一个从 $q_1$ 到 $q_2$ 的箭头，标记为 $a \to b, L$ [cite: 193, 194, 195]，其含义是：

1.  **读 (Read)**：如果当前状态是 $q_1$，且磁头**读到**的符号是 $a$ 。
2.  **写 (Write)**：在磁带的*同一位置* **写入** 符号 $b$ 。
3.  **移 (Move)**：将磁头向**左 (Left)** 移动一个格子。
4.  **变 (Change)**：将状态从 $q_1$ 切换到 $q_2$ 。

同理，$a \to b, R$ 表示读 $a$，写 $b$，然后向**右 (Right)** 移动。

**图灵机是确定性的 (Deterministic)**

* 这意味着在任何 (状态, 符号) 组合下，*最多只有一种*可能的动作。这和 DFA 相同，但和 NFA/NPDA 不同。
* **允许 (Allowed)**：从 $q_1$ 出发，可以有 $a \to b, R$ 和 $b \to d, L$ 两条边。这是确定性的，因为如果读到 'a' 只有一条路可走，读到 'b' 也只有一条路可走。
* **不允许 (Not Allowed)**：从 $q_1$ 出发，*不能*同时有 $a \to b, R$ 和 $a \to d, L$ 两条边。如果读到 'a' 有两种选择，这就是非确定性的。

**TM 如何“接受”和“拒绝”？**

1.  **接受 (Accept)**：当机器执行到一个**接受状态** (accept state，通常是 $H$ 的子集，如图中的 $q_1$) 并**停机** (halt) 。
2.  **拒绝 (Reject)**：

* 机器停机了，但停在一个**非接受状态** (non-accept state)。
* 机器**永不停止**，即陷入了一个**无限循环** (infinite loop)。

**TM 如何“停机” (HALT)？**

* 进入一个定义好的停机状态 (Halting State)，例如 $H$ 中的状态。
* 遇到一个 (状态, 符号) 组合，但在 $\delta$ 中**没有定义**相应的转移。例如，在状态 $q_1$ 读到了符号 'c'，但图中没有 $q_1$ 在 'c' 上的转移，机器会“卡住”，即停机。

---

### 实例分析

![img](./assets/4-2.png)

让我们看一个关键实例：**$L = \{a^n b^n \mid n \ge 1\}$** 。

PDA 可以用栈解决它。TM 如何解决？TM 使用一种完全不同的“来回扫描、做标记”的策略。

1.  从左端开始，找到第一个 $a$，用 $x$ 替换它 (做标记)。
2.  向右移动，跳过所有的 $a$ 和 $y$ (已经标记过的 $b$)。
3.  找到第一个 $b$，用 $y$ 替换它 (做标记)。
4.  现在，一个 $a$ 和一个 $b$ 匹配了。磁头**向左移动**。
5.  向左移动，跳过所有的 $a$ 和 $y$。
6.  直到碰到我们之前留下的 $x$ 标记。
7.  磁头向右移动一步，回到 $x$ 标记后的第一个 $a$ (或 $y$)。
8.  回到状态 $q_0$，重复步骤 1 (寻找下一个 $a$)。

**图解这个过程：**

* $q_0 \xrightarrow{a \to x, R} q_1$ ：找到 $a$，标记为 $x$，向右找 $b$。
* $q_1 \xrightarrow{a \to a, R} q_1$ 和 $q_1 \xrightarrow{y \to y, R} q_1$ ：跳过路上的 $a$ 和 $y$。
* $q_1 \xrightarrow{b \to y, L} q_2$ ：找到 $b$，标记为 $y$，开始向左返回。
* $q_2 \xrightarrow{a \to a, L} q_2$ 和 $q_2 \xrightarrow{y \to y, L} q_2$ ：跳过路上的 $a$ 和 $y$。
* $q_2 \xrightarrow{x \to x, R} q_0$ ：找到 $x$ 标记，右移一格，回到 $q_0$ 准备下一轮。

**如何结束？**

* **接受**：当 $q_0$ 想找 $a$ 时 (步骤 1)，如果它没找到 $a$，而是找到了 $y$ (意味着所有 $a$ 都被标记了)，它就进入 $q_3$ 状态。 $q_3$ 会一路向右，检查是否还有剩余的 $b$ (如果找到 $b$ 就会卡住并拒绝)。如果 $q_3$ 只看到 $y$，最后撞到了空白符号 $\diamond$，说明 $a$ 和 $b$ 完美匹配。它进入 $q_4$ (接受状态) 并停机。
* **拒绝**：如果在 $q_1$ 找 $b$ 时 (步骤 2) 撞到了空白 $\diamond$ (没找到 $b$)，说明 $a > b$，机器停在 $q_1$ (非接受状态)，拒绝。

**关键启示**：
这个例子完美展示了“**读写**”和“**双向移动**”的威力。TM 通过在磁带上“做标记”($x, y$) 来“记忆”信息，这是 FA 和 PDA 都做不到的。

我们可以轻松修改这个机器来识别 $L = \{a^n b^n c^n\}$ 。我们只需要在 $q_2$ (标记完 $b$) 之后，再向右找 $c$ 并标记为 $z$，然后再一起返回最左端。这是 PDA 绝对无法做到的！

---

### 瞬时描述：格局 (Configuration)

一个格局 (Configuration) 必须包含三样东西：

1.  **$q$**：当前的状态。
2.  **$\triangleright x$**：从左端点 $\triangleright$ 开始，到**磁头左边**的所有内容。
3.  **$y$**：从**磁头当前位置**开始，到“最右边的非空白符号”为止的所有内容。

**形式化表示**：$(q, \triangleright x, y)$。(磁头正指向 $y$ 的第一个符号 )

**简化的表示法**

这个三元组 $(q, \triangleright x, y)$ 写起来很麻烦。一种更直观的“简化表示法”是把**当前状态 $q$ 直接插入到磁带字符串中，放在磁头所指符号的*前面***。

**例子 1**：格局 $(q, \triangleright a, aba)$。

* $q$ 是状态。
* 磁头左边是 $\triangleright a$。
* 磁头指向 $a$，后面是 $ba$。
* 磁带是 $\triangleright a a b a$。
* 简化表示为：$(q, \triangleright \underline{a} a b a)$ (下划线表示磁头位置)。

**例子 2**：格局 $(h, \triangleright\sqcup\sqcup\sqcup, \sqcup a)$。

* $h$ 是状态。
* 磁带是 $\triangleright \sqcup \sqcup \sqcup \sqcup a$。
* 磁头指向倒数第二个 $\sqcup$。
* 简化表示为：$(h, \triangleright \sqcup \sqcup \sqcup \underline{\sqcup} a)$。

**停机格局 (Halted Configuration)**

如果一个格局中的状态 $q$ 属于停机状态集 $H$ ( $q \in H$ )，那么这个格局就叫停机格局。

---

### 计算 (Computation)

我们如何描述图灵机“动起来”的过程？我们使用“产生”(yields) 符号 $\vdash_M$ 来表示机器从一个格局到下一个格局的“一步”推导。

**定义**：$(q_1, w_1 \underline{a_1} u_1) \vdash_M (q_2, w_2 \underline{a_2} u_2)$

这表示机器 $M$ 可以在**一步**之内，从左边的格局变到右边的格局。

这“一步”是怎么发生的？假设 $\delta(q_1, a_1) = (q_2, b)$ ：

**情况 1：写入 (b $\in \Sigma$)**

**情况 2：向左移动 (b = $\leftarrow$)**

* 假设 $\delta(q_1, a_1) = (q_2, \leftarrow)$。
* **例子 (a)**：格局 $(q_1, w b \underline{a_1} u)$。

    * 机器在 $a_1$ 处，状态 $q_1$。
    * 它执行“变 $q_2$，向左移”。
    * 新的格局是 $(q_2, w \underline{b} a_1 u)$。磁头移到了 $b$ 上面。

* **例子 (b)**：格局 $(q_1, w b \underline{\sqcup})$。

    * 在 $a_1=\sqcup$ 处，向左移。
    * 新的格局是 $(q_2, w \underline{b})$。

**情况 3：向右移动 (b = $\rightarrow$)**

* 假设 $\delta(q_1, a_1) = (q_2, \rightarrow)$。
* **例子 (a)**：格局 $(q_1, w \underline{a_1} b u)$。

    * 在 $a_1$ 处，状态 $q_1$。
    * 它执行“变 $q_2$，向右移”。
    * 新的格局是 $(q_2, w a_1 \underline{b} u)$。磁头移到了 $b$ 上面。

* **例子 (b)**：格局 $(q_1, w \underline{a_1})$。

    * 在 $a_1$ 处，右边是 $u=e$ (空)。
    * 向右移，磁头会移到一个**空白符号 $\sqcup$** 上。
    * 新的格局是 $(q_2, w a_1 \underline{\sqcup})$。( *知其所以然*：这就是磁带“无限长”的体现，你总可以向右移动到新的空白格上。)

**计算 (Computation)**

* **$\vdash_M^*$ (多步产生)**：这是 $\vdash_M$ 的“自反传递闭包”。
* **一个计算**：就是一个格局的序列 $C_0, C_1, ..., C_n$，其中 $C_0 \vdash_M C_1 \vdash_M \dots \vdash_M C_n$。
* **计算长度**：这个计算的长度为 $n$ (共 $n$ 步) ，记作 $C_0 \vdash_M^n C_n$。

---

### 模块化编程：组合图灵机

**基本机器**我们可以定义一些非常简单的“原子”机器：

* **$M_a$ (写符号 'a')** ：不管读到什么 (除了 $\triangleright$)，都写入 'a' 并停机。我们把它简写为 **$a$**。
* **$M_\leftarrow$ (左移)**：不管读到什么 (除了 $\triangleright$)，都向左移动一步并停机。简写为 **L**。
* **$M_\rightarrow$ (右移)**：不管读到什么，都向右移动一步并停机。简写为 **R**。

**构建循环**利用这些基本机器，我们可以构建出非常有用的“搜索”循环：

* **$R_{\sqcup}$** ：**向右找到第一个空白格**。
* **$R_{\overline{\sqcup}}$** ：**向右找到第一个非空白格**。
* **$L_{\sqcup}$** ：向左找到第一个空白格。
* **$L_{\overline{\sqcup}}$** ：向左找到第一个非空白格。

**组合规则**这是图灵机的“流程控制”，它定义了我们如何像搭乐高一样组合机器 $M_1, M_2, M_3$。

$$M_1 \xrightarrow{a} M_2$ 且 $M_1 \xrightarrow{b} M_3$$

它的执行逻辑是：

1. 从 $M_1$ 的初始状态 $s_1$ 开始。
2. 执行 $M_1$，直到 $M_1$ 停机 (进入 $H_1$ 中的某个状态)。
3. **检查停机时的符号**：

* 如果停机时，磁头正下方的符号是 'a'，则**不真正停机**，而是立即跳转到 $M_2$ 的初始状态 $s_2$ 。
* 如果停机时，磁头正下方的符号是 'b'，则跳转到 $M_3$ 的初始状态 $s_3$。
* 如果停机在其他符号上，则真正停机。

4.  继续执行 $M_2$ (或 $M_3$)，直到它停机。
5.  整个组合机器的停机状态是 $M_2$ 和 $M_3$ 的停机状态 ($H = H_2 \cup H_3$)。

---

## Computing with Turing Machine

### 任务一：判定语言

我们希望图灵机能像 FA 和 PDA 一样，对一个输入字符串 $w$ 给出“接受”或“拒绝”的答案。但 TM 比它们更复杂，因为它可能*永远不停止*（即无限循环）。因此，我们需要更精确地定义“接受”和“拒绝”。

---

#### 明确的停机状态

为了让“接受”和“拒绝”的意图更清晰，我们引入一个新的约定：

* 我们指定停机状态集 $H$ 由两个特殊状态组成：**$H = \{y, n\}$**。
* **$y$** 代表 "Yes" (是)，即**接受**。
* **$n$** 代表 "No" (否)，即**拒绝**。
* **接受格局 (Accepting Configuration)**：任何状态为 $y$ 的停机格局。
* **拒绝格局 (Rejecting Configuration)**：任何状态为 $n$ 的停机格局。

---

#### “判定”与“递归语言”

这是本节第一个**极其重要**的定义：

* **输入字母表 $\Sigma_0$**：这是我们“喂”给机器的合法输入符号集，它*不*包含特殊的 $\triangleright$ (左端点) 和 $\sqcup$ (空白)。
* **M 接受 $w$**：如果 M 从初始格局 $(s, \triangleright \underline{\sqcup} w)$ 开始，最终停机在一个“接受格局”（$y$ 状态）。
* **M 拒绝 $w$**：如果 M 从初始格局 $(s, \triangleright \underline{\sqcup} w)$ 开始，最终停机在一个“拒绝格局”（$n$ 状态）。

**核心定义：判定 (Decides)**

我们说一个 TM $M$ **“判定”(Decides)** 一个语言 $L$，必须满足以下**两个**条件：

1.  如果 $w \in L$ ( $w$ 属于这个语言)，M 必须**停机并接受** $w$。
2.  如果 $w \notin L$ ( $w$ 不属于这个语言)，M 必须**停机并拒绝** $w$。

"判定" 的关键在于**总是停机**。无论输入什么，这个 TM 必须在有限步骤内给出 "Yes" 或 "No" 的答案，绝不允许无限循环。

**核心定义：递归语言 (Recursive Language)**

如果一个语言 $L$ **存在**一个能“判定”它的图灵机 $M$，那么 $L$ 就被称为**递归语言**。

**示例：$L = \{a^n b^n c^n \mid n \ge 0\}$**

* 这个语言是递归的。

![img](./assets/4-3.png)

* **策略**：

1. **$R$ 状态**：机器从左向右扫描，寻找第一个 $a$。

* 如果找到 $a$，就用 $d$ 替换它 (做标记)，然后进入 $dR$ 状态。
* 如果没找到 $a$，反而找到了 $b$ 或 $c$ (顺序错了)，就跳转到 $n$ (拒绝)。
* 如果没找到 $a$，反而找到了 $\sqcup$ (空白)，意味着所有 $a, b, c$ 都被 $d$ 完美替换了 ( $n=0$ 或 $n>0$ 的情况都匹配完了)，就跳转到 $y$ (接受)。

2. **$dR$ 状态 (第一次)**：机器向右寻找第一个 $b$。

* 如果找到 $b$，用 $d$ 替换它，进入下一个 $dR$ 状态。
* 如果没找到 $b$，反而找到了 $a, c, \sqcup$ (数量不匹配或顺序错)，就跳转到 $n$ (拒绝)。

3.  **$dR$ 状态 (第二次)**：机器向右寻找第一个 $c$。

* 如果找到 $c$，用 $d$ 替换它，进入 $dL_{\sqcup}$ 状态。
* ...

4.  **$dL_{\sqcup}$ 状态**：一个“返回”状态，磁头一直向左，直到碰到 $\triangleright$，然后循环回 $R$ 状态，开始下一轮的 $a-b-c$ 标记。

* 这个 TM *总会停机*，因为它要么在 $(y, n)$ 停机，要么因为找不到匹配项而进入 $n$ 停机。因此，它“判定”了这个语言。

---

#### 停机问题 (The Halting Problem)

* **FA 和 PDA 的区别**：FA 和 PDA *总是会停机*的。它们在读完输入字符串后就会停止。
* **TM 的第三种可能**：图灵机 $M$ (即使是只有 $y, n$ 两个停机状态的 $M$)，除了“接受”或“拒绝”外，还有第三种可能：**永不停止 (failing to halt)**，即陷入无限循环。

这就引出了一个问题：如果我们有一个 TM $M$，它在 $w \in L$ 时停机 (接受)，但在 $w \notin L$ 时*无限循环*，那这个 $M$ 算什么呢？它显然没有“判定” $L$，因为它在 $w \notin L$ 时没有给出 "No" 的答案。

---

#### “半判定”与“递归可枚举语言”

**核心定义：半判定 (Semidecides)**

我们说一个 TM $M$ **“半判定”(Semidecides)** 一个语言 $L$，必须满足：

1. 如果 $w \in L$ ( $w$ 属于这个语言)，M 必须**停机** (我们不在乎它停在 $y$ 还是 $n$，只要停机就行)。
2. 如果 $w \notin L$ ( $w$ 不属于这个语言)，M 必须**永不停止**。

**核心定义：递归可枚举语言 (Recursively Enumerable, r.e.)**

如果一个语言 $L$ **存在**一个能“半判定”它的图灵机 $M$，那么 $L$ 就被称为**递归可枚举语言 (r.e. 语言)**。

**定理：Recursive $\implies$ r.e.**

* **“如果一个语言是递归的，那么它一定是 r.e. 的。”**

* **证明**：

1.  假设 $L$ 是递归的，那么存在一个 TM $M$ “判定”它 (即总在 $y$ 或 $n$ 停机)。
2.  我们构造一个新机器 $M'$：
3.  $M'$ 和 $M$ 几乎一样，但我们修改 $M$ 的“拒绝”逻辑：任何原本会导致 $M$ 进入 $n$ 状态的转移，在 $M'$ 中都改成进入一个“无限循环”的状态。
4.  现在 $M'$ 的行为是：

* 如果 $w \in L$，$M$ 会进入 $y$ (停机)。$M'$ 也会进入 $y$ (停机)。
* 如果 $w \notin L$，$M$ 会进入 $n$ (停机)。$M'$ 则会进入无限循环。

5.  $M'$ 的行为完美符合“半判定”的定义。因此 $L$ 是 r.e. 语言。

“递归”(Recursive) = 总能停机 (好)；“递归可枚举”(r.e.) = 只在 "Yes" 时停机 (次好)。

---

#### 语言示例

* $L = \{w \in \{a,b\}^* \mid w \text{ 至少包含一个 } a\}$。
* Page 21 的图展示了一个“半判定” $L$ 的 TM。
* **策略**：这是一个简单的“搜索”机器。

1.  从 $\triangleright$ 开始，状态为 $R$。
2.  只要读到的符号**不是 $a$** (记为 $\overline{a}$)，就保持 $R$ 状态并向右移动。
3.  一旦读到 $a$，循环条件 $\overline{a}$ 不满足，机器没有下一步动作，于是**停机**。

**分析**：

* 如果 $w \in L$ (例如 "bba")：机器会 $R, R, R$，读到 $a$ 时**停机**。
* 如果 $w \notin L$ (例如 "bbb")：机器会 $R, R, R$，读完 $b$ 后会继续读 $\sqcup, \sqcup, \dots$。因为 $\sqcup$ 也不是 $a$，机器将永远向右移动，**永不停止**。

因此，这个 TM “半判定” $L$，证明了 $L$ 是 r.e. 语言。

---

#### 语言层级总结与性质

**总结**：这页的图展示了语言的“包含”关系：

* **正则语言 (RL)** (被 FA 识别) $\subset$
* **上下文无关语言 (CFL)** (被 PDA 识别) $\subset$
* **递归可枚举语言 (r.e.)** (被 TM 半判定)。
* (图中还暗示了**递归语言**在 CFL 和 r.e. 之间)。
* $a^n b^n c^n$ 和 $ww$ 是 r.e. 语言 (它们也是递归的)，但不是 CFL。

* **递归语言的性质**：

**定理 1：递归语言的“补集”也是递归的**。

* **证明**：如果 $L$ 是递归的，就有 TM $M$ 判定它 (总在 $y$ 或 $n$ 停机)。
* 我们构造 $M'$，只需**交换 $M$ 的 $y$ 和 $n$ 状态**。
* 如果 $w \in L$，$M$ 停在 $y$，$M'$ 就会停在 $n$ (拒绝)。
* 如果 $w \notin L$，$M$ 停在 $n$，$M'$ 就会停在 $y$ (接受)。
* $M'$ 仍然是*总停机*的，它完美地判定了 $\overline{L}$。

**定理 2：递归语言在“并集”和“交集”下是封闭的**。

* **证明 (交集)**：假设 $L_1$ (由 $M_1$ 判定) 和 $L_2$ (由 $M_2$ 判定) 都是递归的。
* 我们构造 $M_{intersect}$：

1.  在输入 $w$ 上运行 $M_1$。
2.  $M_1$ 必定停机。如果 $M_1$ 停在 $n$ (拒绝)，则 $M_{intersect}$ 也停在 $n$ (拒绝)。
3.  如果 $M_1$ 停在 $y$ (接受)，则 $M_{intersect}$ 擦除磁带，重新在 $w$ 上运行 $M_2$。
4.  $M_2$ 必定停机。$M_{intersect}$ 返回 $M_2$ 的答案 ($y$ 或 $n$)。

* 这个 $M_{intersect}$ *总会停机*，并且只有当 $M_1$ 和 $M_2$ 都接受时才接受。因此 $L_1 \cap L_2$ 是递归的。 (并集的构造类似)。

---

### 任务二：计算函数

TM 不仅能回答“是/否”，它还能“处理数据”。FA 和 PDA 只能读，而 TM 可读可写，所以它能把一个输入字符串 $w$ 彻底“转换”成一个输出字符串 $y$ 。

---

#### 函数计算的定义

* **用途**：TM 作为函数计算机，将输入 $w$ 转换为输出 $f(w)$ 。
* **约定** ：

1.  **输入**：初始格局为 $(s, \triangleright \underline{\sqcup} w)$。
2.  **运行**：TM 运行计算。
3.  **输出**：TM **必须停机**，且停机时的磁带内容为 $\triangleright \sqcup y$ ( $y$ 是结果) 。$y$ 就是输出，记为 $M(w) = y$ 。

**核心定义：递归函数 (Recursive Function)**

一个函数 $f: \Sigma_0^* \to \Sigma_0^*$ 是**递归的** (或称“可计算的”)，如果**存在**一个 TM $M$ 来“计算”它 (即对 $f$ 定义域 $D$ 中的所有 $w$，都有 $M(w) = f(w)$)。

---

#### 函数计算示例

**示例 1：复制机 (Copying Machine)**

* **函数**：$f(w) = ww$。
* **策略**：这是一个复杂但很经典的“子程序”示例。其高级策略是：

1.  从 $w$ 的第一个字符 $a$ 开始。
2.  将 $a$ “标记” (例如改写成 $\dot{a}$，或像 Page 26/27 那样，先用 $\sqcup$ 擦除)。
3.  向右跑到 $w$ 后面第一个空白 $\sqcup$ 处。
4.  写入 $a$。
5.  向左跑回被标记的 $\dot{a}$ 处。
6.  将 $\dot{a}$ 恢复成 $a$，并向右移动到下一个字符 $b$。
7.  重复 2-6，直到 $w$ 的所有字符都被复制到后面。

**示例 2：左移机 (Left-shifting Machine $S_{\leftarrow}$)**

* **函数**：$f(\sqcup w) = w \sqcup$ (它将 $\triangleright \sqcup w$ 转换为 $\triangleright w \sqcup$)。
* **策略**：这是一种“蠕虫”式的移动：

1.  从 $\triangleright \underline{\sqcup} a b \dots$ 开始。
2.  `R` (读 $a$) $\to$ `U` (写 $\sqcup$) $\to$ `L` (左移) $\to$ `a` (写 $a$) $\to$ `R` (右移)。
3.  磁带变为 $\triangleright a \underline{\sqcup} b \dots$。
4.  重复这个 $R \to \sqcup \to L \to \text{symbol} \to R$ 的循环，直到整个 $w$ 都向左移动了一格。

---

#### 对数字的递归函数

TM 只能处理字符串，我们如何让它计算 $n+1$ 这样的数学函数？答案是：**编码**。

* **编码**：我们使用二进制字符串来表示自然数 (例如 $w \in \{0, 1\}^*$)。
* **多参数**：我们用 $;$ (分号) 来分隔多个参数，例如 $w_1; w_2; \dots$。
* **定义**：一个数字函数 $f: N^k \to N$ 是**递归的**，如果其对应的*字符串函数* (在二进制编码上操作) 是 TM 可计算的。

**示例 1：后继函数 $succ(n) = n+1$**

* **策略**：这就是二进制加法器。

1.  `R_U L`：转到 $n$ 的最右一位 (L-bit)。
2.  `1` 分支：如果读到 `1`，改为 `0` (进位)，然后 `L` (向左移)，回到循环。
3.  `0` 分支：如果读到 `0`，改为 `1`，**停机** (加法完成)。
4.  `U` 分支：如果读到 $\sqcup$ (空白)，说明遇到了 $n=111\dots1$ 的情况，一路进位到了最左端。此时需要：
5.  `1 S_R`：写入 `1`，然后调用“右移机” $S_R$ (与 $S_{\leftarrow}$ 相反)，把 $n$ 的所有位都向右移一格，给这个新的 `1` 腾出空间。

**示例 2：组合机器**

* 我们可以像搭积木一样组合 TM 来计算复杂函数。
* **函数**：$f(x, y) = \text{if } x > y \text{ then } x+y \text{ else } 0$。
* **策略**：

1.  运行 **Comparator** (比较器) TM 模块。
2.  如果 $x > y$，则将磁带内容传递给 **Adder** (加法器) TM 模块。
3.  如果 $x \le y$，则将磁带内容传递给 **Eraser** (清零器) TM 模块。
4.  最终输出 $x+y$ 或 $0$。

---