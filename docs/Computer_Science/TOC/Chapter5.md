---
statistics: True
comments: true
---

# Chapter 5 | Undecidability

## 引言：我们为什么要学这一章？

在之前的课程中，我们设计了各种自动机（DFA, PDA, TM）来解决问题。

本章的核心问题是：在这个世界上，是否存在图灵机（电脑）永远无法解决的问题？

答案是肯定的。这一章就是要画出“计算”的边界。

---

## 邱奇-图灵论题 (Church-Turing Thesis)

### 什么是“算法”？

在图灵机出现之前，人们对“算法”只有一个模糊的直觉。PPT 展示了函数定义的几种形式：

基本函数：零函数、后继函数等。

原始递归函数 (Primitive Recursive)：可以通过固定次数的循环计算出来的函数。

$\mu$-递归函数 ($\mu$-Recursive)：引入了 while 循环（最小化算子），允许无限循环。

关键结论：

$$\text{直觉上的算法} \approx \text{图灵机 (Turing Machine)}$$

---

### 邱奇-图灵论题 (The Thesis)

论题内容：任何在直觉上被认为是“可计算”的过程，都可以由一台图灵机来实现。

这不是一个可以被数学证明的定理，因为它连接了一个模糊的概念（直觉算法）和一个严格的数学模型（图灵机）。它是一个假设或公理。

至今为止，我们发明的所有计算模型（Lambda 演算、递归函数、现代计算机、量子计算机）在可计算能力上都等价于图灵机。

---

### 语言的层级

这是一个非常重要的地图，请务必记在脑子里：

Regular (正则语言)：由 DFA/NFA 识别。

Context-Free (上下文无关)：由 PDA 识别。

Context-Sensitive (上下文有关)：由 线性有界自动机 (LBA) 识别。

Recursive (递归语言 / 可判定)：图灵机一定会停机并给出 Yes/No。这是我们最喜欢的状态。

Recursively Enumerable (R.E. / 递归可枚举)：图灵机对于 Yes 的输入会停机，但对于 No 的输入可能会死循环 (Loop)。这是“半可判定”。

Undecidable (不可判定)：圆环最外面的部分，图灵机根本搞不定的问题。

---

## 通用图灵机 (Universal Turing Machines, UTM)

### 思想起源

如果每解决一个问题都要造一台专门的机器（像早期的织布机），太麻烦了。我们能不能造一台机器 $U$，它可以模拟任何其他机器 $M$？

这就是软件的思想，$U$ 就是硬件（CPU），输入给它的 $M$ 就是软件代码。

---

### 编码 (Encoding)：如何把机器变成数据？

为了让 $U$ 读懂 $M$，我们需要把 $M$ 的状态、符号、转移函数都变成 $\{0, 1\}$ 字符串。

数学编码规则：

符号编码：假设符号集合 $\Sigma$，用 $a0^j$ 形式编码。

例如：空格 $\sqcup \to a000$, $\triangleright \to a001$。

状态编码：假设状态集合 $K$，用 $q$ 后接二进制编码。

例如：$s \to q00$, $q \to q01$, $h \to q11$。

转移函数 $\delta$ 编码：

一条指令 $\delta(q, a) = (p, b)$ 变成一个四元组字符串。

整个机器 $M$ 就是一串长长的四元组列表。

我们用 $\langle M \rangle$ 表示机器 $M$ 编码后的字符串。

---

### UTM 的工作原理

通用图灵机 $U$ 接收输入 $\langle M, w \rangle$（即机器 $M$ 的代码和它的输入 $w$）。

$$U(\langle M \rangle, w) = M(w)$$

模拟过程：

$U$ 有三条纸带：

Tape 1: 存放 $M$ 的纸带内容（工作区）。

Tape 2: 存放 $M$ 的代码描述 $\langle M \rangle$（查询区）。

Tape 3: 存放 $M$ 当前的状态（寄存器）。

逻辑：$U$ 每次看一眼 Tape 1 的符号和 Tape 3 的状态，去 Tape 2 查表找到对应的指令，然后更新 Tape 1 和 Tape 3。

---

### 停机问题 (The Halting Problem)

#### 为什么会有不可判定问题？(计数论证)

图灵机的数量是可数的 (Countable)，因为每个 TM 都可以编码成一个整数。

语言（问题的集合）的数量是不可数的 (Uncountable)。

结论：甚至都不用构造，从数学上讲，绝大多数语言都是图灵机无法识别的。

---

#### 停机问题的定义

$$H = \{ \langle M \rangle w \mid \text{TM } M \text{ 在输入 } w \text{ 上会停机} \}$$

我们想知道：是否存在一个算法（图灵机），输入任意一段代码 $M$ 和输入 $w$，能百分之百告诉我们 $M$ 是死循环还是会停机？

---

#### 对角线法证明 (Diagonalization Proof)

这是反证法 (Proof by Contradiction)。

假设：$H$ 是递归的（可判定的）。即存在一个万能检测机 $M_0$，它总是能停机并回答 Yes/No。

$$M_0(\langle M, w \rangle) = \begin{cases} \text{Yes (Accept)}, & \text{如果 } M \text{ 在 } w \text{ 上停机} \\ \text{No (Reject)}, & \text{如果 } M \text{ 在 } w \text{ 上死循环} \end{cases}$$

构造：我们利用 $M_0$ 构造一个捣乱的机器 $D$ (Diagonal)，它的输入只有 $\langle M \rangle$：

$D$ 调用 $M_0(\langle M, \langle M \rangle \rangle)$（即问 $M_0$：如果把 $M$ 的代码喂给 $M$ 自己，它会停机吗？）

如果 $M_0$ 说“会停机”：$D$ 就故意进入死循环。

如果 $M_0$ 说“死循环”：$D$ 就立即停机。

矛盾时刻：

现在，把 $D$ 自己的代码 $\langle D \rangle$ 喂给 $D$ 运行，即计算 $D(\langle D \rangle)$：

如果 $D$ 在 $\langle D \rangle$ 上停机 $\to$ 说明 $M_0$ 判定它死循环 $\to$ 矛盾！

如果 $D$ 在 $\langle D \rangle$ 上死循环 $\to$ 说明 $M_0$ 判定它停机 $\to$ 矛盾！

结论：假设不成立，$H$ 是不可判定的（Not Recursive）。

---

#### $H$ 与 $\overline{H}$ 的性质

$H$ 是 R.E. (递归可枚举) 的：因为我们可以运行 UTM 模拟 $M$。如果 $M$ 停机，UTM 就会停机说 Yes。但如果 $M$ 死循环，UTM 也会死循环（无法输出 No）。

$\overline{H}$ (停机问题的补集，即“死循环问题”) 不是 R.E. 的。

定理：如果一个语言 $L$ 和它的补集 $\overline{L}$ 都是 R.E. 的，那么 $L$ 必定是 Recursive 的。

因为 $H$ 不是 Recursive，所以 $\overline{H}$ 连 R.E. 都不是。这意味着：我们甚至无法写程序来“确认”一个程序死循环了（它可能下一秒就停机，也可能永远不停，我们永远不知道）。

---

## 归约 (Reduction) —— 问题的传染性

### 什么是归约？

归约是一种将新问题转化为旧问题的技巧。

记号：$L_1 \leq L_2$ （$L_1$ 归约到 $L_2$）。

意思是：如果我有解决 $L_2$ 的万能神器（Subroutine），我就能造出解决 $L_1$ 的机器。

数学定义：

存在一个可计算函数 $\tau: \Sigma^* \to \Sigma^*$，使得：

$$x \in L_1 \iff \tau(x) \in L_2$$

---

### 归约的逻辑方向（千万别搞反！）

定理：如果 $L_1$ 是不可判定的，且 $L_1 \leq L_2$，那么 $L_2$ 也是不可判定的。

直觉：$L_1$ 已经是一个已知的“绝症”（如停机问题）。如果我们能证明解决 $L_2$ 就能顺便解决 $L_1$，那说明 $L_2$ 至少和 $L_1$ 一样难。因为 $L_1$ 无解，所以 $L_2$ 肯定也无解。

---

### 经典归约案例

PPT 中展示了几个经典的不可判定问题，都是通过从 $H$（通用停机问题）归约而来的：

---

#### 空带停机问题 (Halting on Empty Tape)

问题：给定 $M$，它在空输入 $\epsilon$ 上会停机吗？

归约方法 ($H \to$ 空带问题)：

输入是 $\langle M, w \rangle$。

构造新机器 $M_w$：不管输入什么，先把自己纸带清空，写上 $w$，然后模拟 $M$。

这样：$M_w$ 在空带上停机 $\iff M$ 在 $w$ 上停机。

如果空带问题可解，通用停机问题就可解。矛盾。

---

#### 在任意输入上停机 (Halting on Some Input)

问题：$M$ 是否至少在一个输入上停机？

构造：修改 $M$ 变成 $M'$，$M'$ 忽略真实输入，强行把纸带换成 $\epsilon$ 并运行原机器逻辑。

---

#### 在所有输入上停机 (Halting on Every Input / Total)

问题：$M$ 是不是一个完备的算法（永不死循环）？

这也是不可判定的。

---

#### 机器等价性 (Equivalence)

问题：$L(M_1) = L(M_2)$ 吗？

这比停机问题更难，同样不可判定。

---

## R.E. 语言的性质与莱斯定理 (Rice's Theorem)

### 枚举 (Enumeration)

定义：一个 TM $M$ 枚举 语言 $L$，是指 $M$ 可以不断地打印出属于 $L$ 的字符串 $w_1, w_2, \dots$。

定理：一个语言是 R.E. 的 $\iff$ 它有一个枚举器。

R.E. 的全称就是 Recursively Enumerable。如果 $L$ 是 R.E. 的，我们可以用“Dovetailing (交替模拟/鸽巢)”技术：模拟所有可能的 $w$，第一步模拟 $w_1$，第二步模拟 $w_1, w_2$，第三步模拟 $w_1, w_2, w_3$... 谁停机了就打印谁。

---

### 莱斯定理 (Rice's Theorem) —— 必考点

这个定理是判断不可判定性的“大杀器”。

定理内容：

对于关于 R.E. 语言的任何非平凡 (non-trivial) 属性，判定一个图灵机 $M$ 识别的语言 $L(M)$ 是否满足该属性，是不可判定的。

公式化：

令 $P$ 是 R.E. 语言的一个子集（即一种性质）。

如果：

$P \neq \emptyset$ （至少有一个语言满足它）

$P \neq \text{所有 R.E. 语言}$ （至少有一个语言不满足它）

那么，判定 $\langle M \rangle \in P$ 是不可判定的。

例子：

“$L(M)$ 是空的吗？” $\to$ 不可判定。

“$L(M)$ 是有限集吗？” $\to$ 不可判定。

“$L(M)$ 是正则语言吗？” $\to$ 不可判定。

“$L(M)$ 包含字符串 'hello' 吗？” $\to$ 不可判定。

注意：莱斯定理是关于语言（输入输出行为）的性质，而不是关于机器本身（代码结构）的性质。

“$M$ 有 5 个状态” $\to$ 这是可判定的（数一下代码就行），不适用莱斯定理。

“$M$ 接受空串” $\to$ 这是关于语言的，不可判定。

---

## 更多不可解问题

除了图灵机，其他领域也有不可判定问题：

关于文法 (Grammar) 的问题：

给定任意文法 $G$ 和 $w$，判断 $w \in L(G)$ 是不可判定的（针对 Type-0 文法）。

上下文无关文法 (CFG) 的交集：给定两个 CFG $G_1, G_2$，判断 $L(G_1) \cap L(G_2) = \emptyset$ 是不可判定的。（注意：CFG 的交集不一定是 CFG）。

波斯特对应问题 (Post Correspondence Problem, PCP)：

这是一类关于字符串拼接的多米诺骨牌游戏，也是不可判定的。

铺砖问题 (Tiling Problem)：

给定一组带颜色的地砖，能否铺满整个无限平面且颜色匹配？不可判定。

---