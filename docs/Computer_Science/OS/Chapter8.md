---
statistics: True
comments: true
---

# Chapter 8 | Main Memory

## Background

Program must be brought (from disk) into memory and placed within a process for it to be run

- 程序最初存储在磁盘（硬盘）上，不能直接运行。要运行程序，必须先把它从磁盘加载到主存（RAM），并分配到一个进程空间。只有在主存中的程序，CPU才能直接访问和执行。

Main memory and registers are only storage CPU can access directly

- 寄存器和主存是CPU能直接访问的唯一存储。

Register access in one CPU clock (or less)

- 寄存器：速度最快，CPU每个时钟周期都能访问，容量极小（几十到几百字节）。

Main memory can take many cycles

- 主存：容量大得多，但访问速度比寄存器慢很多，可能需要多个时钟周期。

Cache sits between main memory and CPU registers

- 缓存位于主存和寄存器之间，是一种高速缓冲存储器。

Protection of memory required to ensure correct operation

- 多进程系统中，多个程序同时运行，可能会访问同一块主存。如果没有保护机制，一个进程可能会错误地修改或读取另一个进程的数据，导致系统崩溃或数据泄露。操作系统通过内存保护机制（如地址空间隔离、权限检查），确保每个进程只能访问自己的内存区域，保证系统安全和稳定。

---

## Memory Hierarchy

![img](./assets/8-1.png)

---

## Base and Limit Registers

A pair of base and limit registers define the logical address space

![img](./assets/8-2.png)

- 基址寄存器（Base Register）：存储当前进程在主存中的起始地址（如图中的 300040）。
- 界限寄存器（Limit Register）：存储当前进程可用内存的长度（如图中的 120900）。

这两个寄存器一起定义了进程的逻辑地址空间，即进程能访问的主存范围。

进程发出的地址是“逻辑地址”（从0开始），需要加上基址寄存器的值，转换为主存中的“物理地址”。如果进程访问的逻辑地址超过界限寄存器的值（如大于 120900），操作系统会阻止访问，防止进程越界访问其他进程或操作系统的内存。

---

### Addresses Given in Different Ways

- `program` : Symbolic Address: Addresses in the source program are generally symbolic (such as the variable count).
- 在源代码中，变量或函数的名字就是符号地址。符号地址是人类可读的，编译器还没分配具体内存位置时使用。
- `compiler` : Relocatable Addresses: A compiler typically binds these symbolic addresses to relocatable addresses (such as “14 bytes from the beginning of this module”).
- 编译器把符号地址转换为相对于某个基准的偏移量，比如“从模块起始地址算起第14字节”。可重定位地址不是最终的物理地址，而是相对地址，方便程序在不同内存位置加载。
- `linker` : Absolute Addresses: The linker or loader binds the relocatable addresses to absolute addresses (such as 74014).
- 链接器或加载器把可重定位地址转换为主存中的实际物理地址，比如 74014。绝对地址是程序最终在内存中的位置，CPU直接访问。

---

## Multistep Processing of a User Program

A **compiler** is a computer program (or set of programs) that transforms source code written in a computer language (the **source language**) into another computer language (the **target language**, often having a binary form known as **object code**).

把你写的源代码（如C、Java等）翻译成另一种语言，通常是机器能理解的“目标代码”（object code），比如二进制文件。编译器只负责单个源文件的翻译，生成的目标代码里地址是“可重定位的”，还不能直接运行。

A **linker** or **linkage editor** is a program that takes one or more objects generated by a compiler and combines them into a single executable program.

把编译器生成的一个或多个目标文件（object files）以及需要的库文件，组合成一个完整的可执行程序（如 .exe）。链接器解决了不同模块之间的调用和数据引用，把所有代码和数据拼接到一起，分配好最终的内存地址。

A **loader** loads the .exe file into memory for execution.

把链接器生成的可执行文件（如 .exe）从磁盘加载到主存（RAM）中，为程序分配进程空间，让CPU可以直接运行。加载器负责把文件放到内存合适的位置，并初始化程序运行环境。

![img](./assets/8-3.png)

---

## Binding of Instructions and Data to Memory

Address binding of instructions and data to memory addresses can happen at three different stages

地址绑定就是把程序中的指令和数据分配到实际的内存地址。这个过程可以发生在不同的阶段。（与具体的系统有关系）。

- **Compile time**（编译时刻）: If memory location known a priori, **absolute code** can be generated; must recompile code if starting location changes
- **Load time**（装入时刻）: Must generate **relocatable code** if memory location is not known at compile time
- **Execution time**（执行时刻）: Binding delayed until run time if the process can be moved during its execution from one memory segment to another. Need hardware support for address maps (e.g., base and limit registers)

- 编译时：如果程序的内存位置在编译时就已经确定，编译器可以直接生成绝对代码，即所有地址都是最终的物理地址。缺点是如果以后程序要加载到不同的位置，必须重新编译。
- 如果编译时不知道程序会被加载到哪里，编译器生成可重定位代码，即地址是相对的（偏移量）。当程序被加载到内存时，加载器会根据实际起始地址，把所有相对地址转换为绝对地址。好处是程序可以灵活地加载到不同内存位置，无需重新编译。
- 执行时：如果程序在运行过程中可能会被移动（比如分段、分页、虚拟内存），地址绑定会延迟到运行时。每次CPU访问内存时，硬件会把逻辑地址转换为物理地址。好处是程序可以在运行时自由移动，支持高级内存管理（如虚拟内存、多进程隔离）。但是需要硬件支持地址映射，比如基址和界限寄存器、页表等。

---