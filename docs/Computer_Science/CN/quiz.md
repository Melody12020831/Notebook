---
statistics: True
comments: true
---

# quiz

## quiz 1/25秋

<div class="card file-block" markdown="1">
<div class="file-icon"><img src="/Notebook/assets/images/pdf.svg" style="height: 3em;"></div>
<div class="file-body">
<div class="file-title"> quiz1 </div>
<div class="file-meta"> 2,124 KB / 2025-11-05</div>
</div>
<a class="down-button" target="_blank" href="/Notebook/Computer_Science/CN/小测1解析.pdf" markdown="1">:fontawesome-solid-download: 下载</a>
</div>

---

## quiz 1/24秋

![img](./assets/qz1-1.png)

??? note
    这是一个关于网络协议分层和数据封装的问题。我们可以按照以下步骤来解决它：

    1. 确定总的报头（Header）大小

    问题中提到，系统有一个7层协议栈，并且**每一层**都会添加一个20字节的报头。

    * 层数：7 层

    * 每层添加的报头大小：20 字节

    * **总报头大小** = $7 \times 20 \text{ 字节} = 140 \text{ 字节}$

    2. 确定总的传输数据大小

    总的传输数据是原始消息（数据）和所有报头的总和。

    * 原始消息大小：1000 字节

    * 总报头大小：140 字节

    * **总传输大小** = $\text{原始消息} + \text{总报头} = 1000 \text{ 字节} + 140 \text{ 字节} = 1140 \text{ 字节}$

    3. 计算报头所占的带宽比例

    问题要求的是报头所占的“fraction”（分数或比例）。这可以通过用总报头大小除以总传输大小来计算。

    * **比例（Fraction）** = $\frac{\text{总报头大小}}{\text{总传输大小}}$

    * 比例 = $\frac{140}{1140} \approx 0.1228...$

    4. 按要求取整

    问题要求 "(round to integer)"（四舍五入到整数）。这通常是要求将比例转换为**百分比**，然后再四舍五入。

    * **百分比** = $0.1228... \times 100 \approx 12.28... \%$

    * 将 $12.28...$ 四舍五入到最接近的整数，得到 **12**。

![img](./assets/qz1-2.png)

??? note
    这是一个关于计算网络传播延迟的问题。以下是详细的步骤：

    1. 理解延迟的构成

    问题要求计算“in response to a request”（对一个请求的响应）的“best-case delay”（最佳情况延迟）。

    * **最佳情况（Best-case）**：这通常意味着我们只考虑**传播延迟**（Propagation Delay），即信号以光速在介质中传播所需的时间。我们忽略其他延迟，如传输延迟（取决于带宽）、处理延迟和排队延迟。

    * **对请求的响应**：这表示一个完整的**往返时间 (Round Trip Time, RTT)**。信号需要走过以下路径：

        1.  **请求**：客户端 $\rightarrow$ 卫星 $\rightarrow$ 服务器
        
        2.  **响应**：服务器 $\rightarrow$ 卫星 $\rightarrow$ 客户端

    2. 计算总传播距离

    信号需要走 4 个单程（"hop"）：

    1.  客户端 (上行) $\rightarrow$ 卫星：40,000 km

    2.  卫星 (下行) $\rightarrow$ 服务器：40,000 km

    3.  服务器 (上行) $\rightarrow$ 卫星：40,000 km

    4.  卫星 (下行) $\rightarrow$ 客户端：40,000 km

    * **总距离** = $4 \times 40,000 \text{ km} = 160,000 \text{ km}$

    3. 计算传播延迟

    信号（如无线电波）在太空或大气中的传播速度约等于光速（$c$）。

    * **光速 ($c$)** $\approx 300,000 \text{ km/s}$

    现在，我们可以用 $时间 = \frac{\text{距离}}{\text{速度}}$ 来计算总延迟。

    * **延迟 (秒)** = $\frac{160,000 \text{ km}}{300,000 \text{ km/s}} = \frac{16}{30} \text{ s} \approx 0.5333... \text{ s}$

    4. 转换单位并取整

    问题要求答案以毫秒（msec）为单位，并四舍五入到整数。

    * $1 \text{ 秒} = 1000 \text{ 毫秒}$

    * **延迟 (毫秒)** = $0.5333... \text{ s} \times 1000 \text{ msec/s} = 533.333... \text{ msec}$

    将 $533.333...$ 四舍五入到最接近的整数，得到 **533**。

![img](./assets/qz1-3.png)

??? note
    这是一个关于OSI七层模型功能的选择题。

    以下是每个选项的详细解释：

    * **A. 物理层关心的是在通信信道上传输原始比特流。**

    * **正确 (Correct)**。物理层（Physical Layer, L1）是OSI模型的第一层。它的主要功能是定义物理设备（如网线、光纤、集线器）的电气、机械和功能特性，以便在物理媒介上传输原始的二进制比特流（0和1）。

    * **B. 数据链路层是一个真正的端到端层，从源头一直到目的地。**

    * **错误 (Incorrect)**。数据链路层（Data Link Layer, L2）**不是**一个端到端（end-to-end）层。它的作用范围是**点对点（point-to-point）**或**跳到跳（hop-to-hop）**，即在*同一个*物理网络（例如一个局域网LAN）中的相邻两个节点之间。当数据包需要跨越多个网络（例如通过路由器）时，每一“跳”（从一个路由器到下一个路由器）都会涉及数据链路层，但它只关心这一小段链路。

    * 真正的“端到端”层（从源主机到目的主机）是**传输层（Transport Layer, L4）**。

    * **C. 网络层控制子网的操作，并决定分组如何从源路由到目的地。**

    * **正确 (Correct)**。网络层（Network Layer, L3）的主要任务是在一个或多个网络（子网）中，为数据包（packets）找到从源主机到目的主机的最佳路径。这个过程称为**路由（routing）**。它使用逻辑地址（如IP地址）来实现这一点。

    * **D. 应用层包含用户通常需要的各种协议。**

    * **正确 (Correct)**。应用层（Application Layer, L7）是OSI模型的最高层，它直接面向用户和应用程序。它提供了用户与网络交互的接口，包含了我们熟知的各种协议，如 HTTP（网页）、FTP（文件传输）、SMTP（电子邮件）、DNS（域名解析）等。

![img](./assets/qz1-4.png)

??? note
    这是一个经典的网络通信理论问题，涉及奈奎斯特（Nyquist）和香农（Shannon）的理论。

    详细解释

    这道题的关键在于理解“**noiseless (无噪声)**”信道的含义。

    1.  **相关的理论：**

    * **奈奎斯特准则 (Nyquist Formula)**：用于计算*无噪声*信道的最大数据速率。
    * **香农定理 (Shannon's Theorem)**：用于计算*有噪声*信道的最大数据速率（信道容量）。

    2.  **分析问题中的条件：**

    * **"A noiseless 2-k Hz channel"（一个无噪声的 2-k Hz 信道）**：

    * **信道带宽 ($B$)** = $2 \text{ kHz} = 2000 \text{ Hz}$。
    * **"Noiseless"（无噪声）**：这是本题最重要的线索。它告诉我们应该使用奈奎斯特准则，而不是香农定理。

    3.  **应用奈奎斯特准则：**

    奈奎斯特的公式是：

    $$R_{\text{max}} = 2 \times B \times \log_2(L)$$

    其中：

    * $R_{\text{max}}$ 是最大数据速率（单位：bps）。
    * $B$ 是信道带宽（单位：Hz）。
    * $L$ 是用于表示数据的信号电平（或符号）的数量。

    4.  **"无噪声"的含义：**

    * 在一个*理论上*完全没有噪声的信道中，接收端可以完美地区分出发射端发送的任何信号电平，无论它们之间的差异有多么微小（例如，可以区分 0.001 伏和 0.002 伏）。

    * 这意味着，我们可以使用**无限多个信号电平**（$L \rightarrow \infty$）来编码数据。

    * 如果 $L$ 趋向于无穷大，那么 $\log_2(L)$ 也趋向于无穷大。

    5.  **计算结果：**

    $$R_{\text{max}} = 2 \times 2000 \text{ Hz} \times \log_2(\infty) = \infty$$

    因此，一个无噪声信道的理论最大数据速率是**无限的 (infinite)**。

    为什么其他选项是错误的？（陷阱分析）

    这道题设置了两个主要的陷阱：

    **陷阱 1："sampled every 1 msec"（每1毫秒采样一次）**

    * $采样间隔 = 1 \text{ msec} = 0.001 \text{ s}$

    * $采样率 (f_s) = \frac{1}{0.001 \text{ s}} = 1000 \text{ Hz}$

    * 这个信息是一个**干扰项**。它描述的是一个*正在发生*的操作（采样），而不是信道*本身*的固有属性或容量。信道的理论最大容量是由其带宽和噪声水平决定的，而不是由我们选择的采样率决定的。

    **陷阱 2：选项 C (4000 bps)**

    * 这个数字是怎么来的？它是假设信号是**二进制**的（即 $L=2$，只有两个信号电平，如0和1）。
    
    * $R = 2 \times B \times \log_2(2) = 2 \times 2000 \times 1 = 4000 \text{ bps}$

    * 这确实是该信道在*使用二进制信号时*的最大速率，但题目问的是**“maximum data rate”（最大数据速率）**，而“noiseless”（无噪声）这个条件允许我们使用超过2个电平（$L > 2$），因此 4000 bps 不是*理论上*的最大值。

    **总结：**
    由于信道是“无噪声”的，我们可以使用无限多个信号电平（$L \rightarrow \infty$）来传输数据，根据奈奎斯特公式，这导致了无限的理论最大数据速率。

![img](./assets/qz1-5.png)

??? note
    这是一个关于计算信道容量的经典问题。我们使用**奈奎斯特准则（Nyquist formula）**来解决它。

    1. 确定使用的公式

    问题中给出了两个关键信息：

    1.  **"Assume a noiseless channel"（假设一个无噪声信道）**

    2.  **"128-level digital signals are used"（使用128个电平的数字信号）**

    当信道无噪声，并且指定了信号电平数（$L$）时，我们使用奈奎斯特公式来计算最大数据速率（$R$）：

    $$R = 2 \times B \times \log_2(L)$$

    其中：

    * $R$ 是最大数据速率 (bits per second, bps)

    * $B$ 是信道带宽 (Hertz, Hz)

    * $L$ 是信号电平的级数

    2. 提取已知变量

    从题目中我们可以得到：

    * **带宽 ($B$)**：$16 \text{ MHz} = 16 \times 10^6 \text{ Hz}$

    * **信号电平数 ($L$)**：128

    3. 计算 $\log_2(L)$

    这一项代表“每个信号电平（或符号）可以携带多少比特（bit）的信息”。

    $\log_2(128) = 7$。这意味着每个信号符号可以代表 7 个比特。

    4. 代入公式计算

    现在我们将所有值代入奈奎斯特公式：

    $$R = 2 \times B \times \log_2(L)$$

    $$R = 2 \times (16 \times 10^6 \text{ Hz}) \times 7$$

    $$R = 32 \times 10^6 \times 7 \text{ bps}$$

    $$R = 224 \times 10^6 \text{ bps}$$

    5. 转换单位

    题目要求答案以 **Mbps**（Megabits per second，兆比特每秒）为单位。

    * $1 \text{ Mbps} = 10^6 \text{ bps}$

    * 因此，$224 \times 10^6 \text{ bps} = 224 \text{ Mbps}$

    **最终答案：**

    可以发送的速率是 **224** Mbps。

![img](./assets/qz1-6.png)

??? note
    在CDMA系统中，每个站点（A, B, C, D）都被分配了一个唯一的、相互**正交**（orthogonal）的码片序列（chip sequence）。

    * 当一个站点发送 **bit 1** 时，它发送其原始码片序列。

    * 当一个站点发送 **bit 0** 时，它发送其码片序列的**反码**（所有+1和-1颠倒）。

    * 当一个站点**静默 (silence)** 时，它发送全 0 序列。

    接收端收到的信号（chips）是所有站点发送信号的**线性叠加**（总和）。

    **解码原理：**

    要解码特定站点（例如站点 C）发送了什么，接收端需要计算**接收到的码片序列**与**站点 C 的码片序列**之间的**内积（dot product）**。

    我们用 $R$ 表示接收到的序列，用 $C$ 表示站点 C 的码片序列。

    **1. 提取已知信息：**

    * **接收序列 ($R$)**: $R = (-1, +1, -3, +1, -1, -3, +1, +1)$

    * **站点 C 序列 ($C$)**: $C = (-1, +1, -1, +1, +1, +1, -1, -1)$

    **2. 计算内积 ($R \cdot C$)**

    我们将两个序列的对应位置相乘，然后将所有结果相加：

    $$S = R \cdot C = \sum (R_i \times C_i)$$

    **3. 求和：**

    $$S = 0$$

    **4. 解释计算结果：**

    内积的结果有三种可能：

    * **如果结果是一个大的正数**（等于码片序列的长度，这里是 8）：说明站点 C 发送了 **bit 1**。

    * **如果结果是一个大的负数**（等于码片序列长度的负数，这里是 -8）：说明站点 C 发送了 **bit 0**。

    * **如果结果是 0**：说明站点 C **静默（silence）**，没有发送数据。

    由于我们的计算结果是 **0**，因此站点 C 处于静默状态。

![img](./assets/qz1-7.png)

??? note
    这是一个关于计算有噪声信道最大数据速率（即信道容量）的典型问题。我们使用**香农-哈特利定理（Shannon-Hartley Theorem）**来解决。

    1. 确定使用的公式

    题目中提到了“noisy channel”（有噪声的信道）、“bandwidth”（带宽）和“signal-to-noise ratio (S/N)”（信噪比）。这三个关键信息指向了香农定理：

    $$C = B \times \log_2(1 + S/N)$$

    其中：

    * $C$ 是信道容量，即最大数据速率（单位：bps）。

    * $B$ 是信道带宽（单位：Hz）。

    * $S/N$ 是信噪比，必须是**线性的功率比值**（而不是分贝 dB）。

    2. 提取已知变量并转换单位

    * **带宽 ($B$)**:

    $$B = 5 \text{ KHz} = 5000 \text{ Hz}$$

    * **信噪比 ($S/N$)**:

    题目给出的是 $30 \text{ dB}$（分贝）。我们必须将其转换为线性的 $S/N$ 比值。

    转换公式为：

    $$\text{dB} = 10 \times \log_{10}(S/N)$$

    将 $30 \text{ dB}$ 代入：

    $$30 = 10 \times \log_{10}(S/N)$$

    $$3 = \log_{10}(S/N)$$

    为了解出 $S/N$，我们以 10 为底：

    $$S/N = 10^3 = 1000$$

    所以，30 dB 的信噪比意味着信号的功率是噪声功率的 1000 倍。

    3. 代入香农公式计算

    现在我们将 $B = 5000 \text{ Hz}$ 和 $S/N = 1000$ 代入香农公式：

    $$C = 5000 \times \log_2(1 + 1000)$$

    $$C = 5000 \times \log_2(1001)$$

    4. 估算对数值

    计算 $\log_2(1001)$ 是关键。在考试和实际估算中，我们通常使用一个非常接近的近似值：

    * 我们知道 $2^{10} = 1024$。
    * $1001$ 非常接近 $1024$。
    * 因此，$\log_2(1001) \approx \log_2(1024) = 10$。

    5. 计算最终速率

    使用这个近似值，我们得到：

    $$C \approx 5000 \times 10$$

    $$C \approx 50,000 \text{ bps}$$

    6. 转换单位并取整

    题目要求答案以 **kbps**（kilobits per second）为单位，并四舍五入到整数。

    * $1 \text{ kbps} = 1000 \text{ bps}$

    * $C = \frac{50,000 \text{ bps}}{1000} = 50 \text{ kbps}$

    这个结果 50 已经是一个整数。

    **最终答案：**

    该信道的最接近的最大数据速率是 **50** kbps。

![img](./assets/qz1-8.png)

??? note
    列出式子后计算可以得到 0010。

![img](./assets/qz1-9.png)

??? note
    $$2^{3-1} = 2^2 = 4$$

![img](./assets/qz1-10.png)

??? note
    详细解释

    我们来逐步分解这个过程：

    1.  **理解 Go-Back-N (GBN) 协议：**

    * **发送方：** 可以连续发送一个窗口内的多个帧（在本例中，它发送了 0 到 6）。

    * **接收方：** 只按顺序接收帧。如果它期望接收帧 $n$，但收到了帧 $n+1$，它会丢弃帧 $n+1$。

    * **确认机制：** GBN 使用**累积确认**。

    2.  **理解“累积确认” (Cumulative Acknowledgment)：**

    * 这是本题的**最关键点**。

    * 当接收方发送一个确认帧 $ACK_n$ 时，它**不仅仅**是确认收到了第 $n$ 帧。

    * 它真实的意思是：“**我已经成功接收了包括第 $n$ 帧在内的、按顺序排列的所有帧（即 0, 1, 2, ..., $n$）**。我现在期望接收的是第 $n+1$ 帧。”

    3.  **分析题目中的情景：**

    * **发送方**发送了帧：0, 1, 2, 3, 4, 5, 6。

    * **发送方**在超时结束时，收到了 $ACK_1$, $ACK_3$, $ACK_5$。

    * 我们来分析发送方收到最后一个 $ACK_5$ 时，发送方所知道的状态：

        * $ACK_5$ 是一个累积确认。

        * 它告诉发送方，接收方已经**成功并按顺序**接收了所有帧，直到**帧 5**（即 0, 1, 2, 3, 4, 5 都已确认）。

        * 即使 $ACK_0$, $ACK_2$, $ACK_4$ 在传输过程中丢失了， $ACK_5$ 的到达也足以确认 0 到 5 所有的帧。

    4.  **确定当前状态和超时：**

    * 在收到 $ACK_5$ 之后，发送方知道帧 0、1、2、3、4、5 都已成功。

    * 唯一已发送但**未被确认**的帧现在是**帧 6**。

    * 发送方为它发送的每个未确认的帧维护一个计时器（或者在GBN中，通常只为窗口中的*第一个*未确认的帧维护一个计时器）。

    * 在这种情况下，发送方发送了 0-6。收到 $ACK_5$ 后，窗口的“基（base）”移动到了 6。发送方现在正在等待 $ACK_6$。

    * 题目中提到“at the end of timeout”（超时）。这个超时必定是针对当前**最早未被确认**的帧，也就是**帧 6**。

    5.  **GBN 的重传策略：**

    * 当 GBN 协议中发生超时时，它会重传所有**已发送但未被确认**的帧。

    * 由于帧 0-5 已经被 $ACK_5$ 累积确认了，唯一超时（即未被确认）的帧是**帧 6**。

    * 因此，发送方将重传**帧 6**（以及在帧 6 之后发送的任何其他帧，但本例中没有）。

    **结论：**

    由于累积确认 ($ACK_5$) 的存在，帧 0-5 都被视为已送达。唯一已发送但未确认的帧是**帧 6**。因此，当超时发生时，必须是帧 6 的计时器超时了，发送方会重传**帧 6**。

---

## quiz 1/23秋

![img](./assets/qz1-11.png)

![img](./assets/qz1-12.png)

??? note
    这是一个关于计算机网络中物理层（Physical Layer）的经典计算题。

    这个问题的核心是计算一个数据位（bit）在物理介质（如电缆）上传播时所占据的**物理长度**。

    **核心概念**

    “比特的长度”并不是指它存储在硬盘上的大小，而是指当发送方以特定速率（传输速率）发送一个比特时，在这个比特**发送完毕**的瞬间，该比特的“前沿”已经在介质中**传播**出去了多远。

    * **传输速率 (Transmission Speed):** 决定了发送一个比特需要**多长时间**（称为“位持续时间”）。

    * **传播速度 (Propagation Speed):** 决定了信号在介质中（如电缆）传播得**有多快**。

    **计算公式**

    比特长度（米） = 传播速度（米/秒） × 位持续时间（秒）

    **详细计算步骤**

    **1. 确定已知信息：**

    * **传输速率 ($R$)：** 10 Mbps (Megabits per second) = $10 \times 10^6$ bits/second（即每秒 1000 万比特）。
    * **传播速度 ($V_p$)：** 真空中的光速 (c)的三分之二，其标准值约为 $3 \times 10^8 \times \frac{2}{3} = 2 \times 10^8$ m/s。

    **2. 计算“位持续时间” ($T_{bit}$)**

    “位持续时间”是指发送 1 个比特所需要的时间。如果每秒钟可以发送 $10 \times 10^6$ 个比特，那么发送 1 个比特所需的时间就是传输速率的倒数：

    $$T_{bit} = \frac{1}{\text{传输速率}} = \frac{1}{R}$$

    $$T_{bit} = \frac{1}{10 \times 10^6 \text{ bps}} = 10^{-7} \text{ 秒}$$

    （这等于 0.1 微秒，µs）

    **3. 计算比特的物理长度 ($L_{bit}$)**

    现在我们知道了发送 1 个比特需要 $10^{-7}$ 秒。我们使用主公式，将这个时间乘以信号的传播速度，就能得到在这段时间内信号传播的距离：

    $$L_{bit} = \text{传播速度} \times \text{位持续时间}$$

    $$L_{bit} = V_p \times T_{bit}$$

    $$L_{bit} = 20 \text{ 米}$$

    ---

    ### 结论

    因此，在 10 Mbps 的传输速率和光速的传播速度下，一个比特在介质中的物理长度是 **20米**。

    > **补充背景：**
    > 这个问题在早期的 802.3 以太网中非常重要。当时使用的 CSMA/CD（载波侦听多路访问/冲突检测）协议要求，发送方必须能在其发送的帧的“第一个比特”到达网络最远端*之前*，就检测到是否有其他设备也在同时发送（即“冲突”）。这个“比特长度”是计算网络最大物理跨度（网段长度）和最小帧长的关键参数。

![img](./assets/qz1-13.png)

![img](./assets/qz1-14.png)

??? note
    $$1024 \times 768 \times 8 \div 10^7 \approx 1.887 \text{ seconds}$$

![img](./assets/qz1-15.png)

![img](./assets/qz1-16.png)

??? note
    **什么是 PDU (Protocol Data Unit)？**

    PDU（协议数据单元）是OSI模型中，**每一层**用来称呼其处理的数据“块”的专用术语。

    当数据从顶层（应用层）向下传递时，每一层都会在上一层的数据上“包装”上自己的控制信息（称为**头部 Header**），这个过程叫做**封装 (Encapsulation)**。这个被封装后的、特定层的数据单元就叫做该层的PDU。

    **OSI模型各层的PDU名称：**

    为了理解为什么 C 是对的，我们来看一下最关键的几层PDU：

    1. **L7 应用层 (Application Layer):**

    * PDU: **Message (消息)** 或 **Data (数据)**。这是用户程序（如浏览器）创建的原始数据。

    2. **L4 传输层 (Transport Layer):**

    * PDU: **Segment (段)** [如果使用 TCP 协议] 或 **Datagram (数据报)** [如果使用 UDP 协议]。
    * *功能：* 它接收来自应用层的 Message，并添加端口号（Port Number）等信息，用于管理端到端的连接。
        
    3. **L3 网络层 (Network Layer):**

    * PDU: **Packet (包 或 分组)**。
    * *功能：* 它接收来自传输层的 Segment，并添加IP地址（逻辑地址）等信息，用于在**不同网络之间**进行**路由 (Routing)**。

    4. **L2 数据链路层 (Data Link Layer):**

    * PDU: **Frame (帧)**。
    * *功能：* 它接收来自网络层的 Packet，并添加MAC地址（物理地址）等信息，用于在**同一个局域网**（或一个链路）内进行传输。

    5. **L1 物理层 (Physical Layer):**

    * PDU: **Bit (比特)**。
    * *功能：* 将数据帧转换为电子信号（0和1）在物理介质（如网线）上传输。

![img](./assets/qz1-17.png)

![img](./assets/qz1-18.png)

??? note
    **什么是“面向连接的服务” (Connection-Oriented Service)？**

    “面向连接”的服务模型模仿了传统的电话系统。在真正开始通信（传输数据）之前，发送方和接收方必须先“握手”来建立一个专用的逻辑连接。

    这个服务模型具有三个清晰的阶段：

    1.  **建立连接 (Connection Setup):** 双方协商通信参数，并在网络中建立一个逻辑路径。

    2.  **数据传输 (Data Transfer):** 所有的数据包都会沿着这条已经建立好的路径**按顺序**传输。

    3.  **释放连接 (Connection Teardown):** 数据传输完成后，该连接被拆除。

    **分析各个选项：**

    **A. virtual circuit service (虚拟电路服务):**

    * 这正是“面向连接”服务的**定义**。它在网络中建立一个“虚拟”的电路。一旦建立，所有数据包都会像在物理电路上一样，沿着这条固定路径按顺序到达目的地。这确保了数据的顺序和可靠性。

    **B. acknowledged datagram service (确认数据报服务):**

    * 这是一种“无连接”服务（datagram service）的**增强版**。它虽然通过“确认”（acknowledgment）机制来确保每个数据报都被收到了（增加了可靠性），但它**并没有在传输前建立一个固定的连接或路径**。它仍然是无连接的，只是更可靠。

    **C. client-server service (客户端-服务器服务):**

    * 这是一个**应用架构模型**，描述的是软件程序之间的角色（一个请求服务，一个提供服务）。它**不是**一个网络层或传输层的“服务模型”。

    * 客户端-服务器应用（如Web浏览）可以*使用*面向连接的服务（如TCP），但它本身*不是*那个服务模型。

    **D. datagram service (数据报服务):**

    * 这是“无连接服务”（Connectionless Service）的典型代表。每个数据包（称为“数据报”）都包含完整的目的地址，并被网络独立地路由。

    * 它**不需要预先建立连接**，数据包可能走不同的路径，导致它们可能**失序**、**丢失**或**重复**。

![img](./assets/qz1-19.png)

??? note
    **详细解释**

    这个问题的核心是“**成帧 (Framing)**”。

    **1. 什么是成帧 (Framing)？**

    在OSI模型中，数据自上而下传递。

    * **L3 网络层 (Network Layer)** 传递下来的是 **包 (Packet)**。

    * **L1 物理层 (Physical Layer)** 负责在物理介质（如网线、光纤）上传输原始的**比特流 (Bit Stream)**，也就是一长串 0 和 1。

    物理层本身并不理解数据的含义或结构。在它看来，所有数据都是一个连续的、没有边界的比特流。

    **数据链路层 (Data Link Layer, L2)** 的核心职责之一，就是在发送端将 L3 的“包”封装成“**帧 (Frame)**”，并在接收端从 L1 的“比特流”中**识别出“帧”的边界**。

    **2. 为什么需要“帧”？**

    数据链路层必须把原始的比特流“分割”成一个个可管理的、有明确**起点**和**终点**的数据块，这个数据块就叫做“帧”。这样做有几个关键目的：

    * **差错检测 (Error Detection):**数据链路层会在每个“帧”的末尾（称为**尾部 Trailer**）添加一个**帧校验序列 (FCS)**，如 CRC 校验码。当接收方收到一个帧时，它会重新计算校验码并与FCS进行对比。如果整个比特流没有被“分割”成帧，接收方就无法知道应该对哪一段数据进行校验，也无法定位错误。

    * **物理寻址 (Physical Addressing):**数据链路层会在“帧”的**头部 (Header)** 添加源和目的地的**MAC地址**（物理地址），以确保数据能在本地局域网（LAN）中被发送到正确的设备。

    * **流量控制 (Flow Control):**通过以“帧”为单位进行通信，接收方可以告诉发送方“我处理不过来了，请暂停发送帧”，从而避免数据丢失。

    因此，将比特流划分为帧（dividing the transmitted bit stream into frames）是**数据链路层**的标志性功能。

![img](./assets/qz1-20.png)

---